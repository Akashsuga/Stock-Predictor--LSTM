# -*- coding: utf-8 -*-
"""lstm_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Fl8Gdi0FU_6GcYcq51ZLqmfNM4kN24zJ
"""

import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf
import datetime
import os
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error

# TensorFlow/Keras imports with error handling
try:
    import tensorflow as tf
    from tensorflow import keras
    from tensorflow.keras.models import Sequential, load_model
    from tensorflow.keras.layers import LSTM, Dropout, Dense
    from tensorflow.keras.callbacks import ReduceLROnPlateau
    TENSORFLOW_AVAILABLE = True
except ImportError:
    st.error("TensorFlow not installed. Please install tensorflow>=2.11.0")
    TENSORFLOW_AVAILABLE = False

# --- Page Configuration and Custom Styling ---
st.set_page_config(page_title="Stock Forecast App", layout="wide")
st.markdown("""
    <style>
        .main {background-color: #f5f5f5; color: #333;}
        h1, h2, h3 {color: #1f77b4;}
        .stButton>button {
            background-color: #1f77b4;
            color: white;
            font-weight: bold;
            border-radius: 5px;
        }
        .css-18e3th9 {background-color: #f5f5f5;}
    </style>
""", unsafe_allow_html=True)

# --- Application Title ---
st.title("📊 LSTM-Based Stock Forecast Dashboard")

# --- Sidebar Navigation ---
st.sidebar.title("Navigation Panel")
page = st.sidebar.radio("Select Section", ["Overview", "Select Company", "Data Upload", "Train Model", "Forecast"])

# --- Initialize session state for model ---
if 'model' not in st.session_state:
    st.session_state.model = None
if 'model_trained' not in st.session_state:
    st.session_state.model_trained = False

# --- Load or Train Model Function ---
def load_or_create_model():
    """Load existing model or create new one"""
    if os.path.exists("lstm_model.keras"):
        try:
            model = load_model("lstm_model.keras")
            st.session_state.model = model
            st.session_state.model_trained = True
            return model
        except Exception as e:
            st.warning(f"Could not load existing model: {e}")
            return None
    else:
        st.info("No pre-trained model found. Please train a new model.")
        return None

# --- Model Training Function ---
def train_new_model(data):
    """Train a new LSTM model"""
    if not TENSORFLOW_AVAILABLE:
        st.error("Cannot train model - TensorFlow not available")
        return None
    
    try:
        # Preprocess data
        df, scaled_data, scaler = preprocess_data(data)
        x, y = create_dataset(scaled_data)
        
        # Split data
        train_size = int(len(x) * 0.8)
        x_train, x_test = x[:train_size], x[train_size:]
        y_train, y_test = y[:train_size], y[train_size:]
        
        # Build model
        model = Sequential()
        model.add(LSTM(128, return_sequences=True, input_shape=(x_train.shape[1], x_train.shape[2])))
        model.add(Dropout(0.3))
        model.add(LSTM(128))
        model.add(Dropout(0.3))
        model.add(Dense(1))
        
        model.compile(optimizer='adam', loss='mean_squared_error')
        
        # Train model
        with st.spinner("Training model... This may take a few minutes."):
            reduce_lr = ReduceLROnPlateau(monitor='val_loss', factor=0.5, patience=5, min_lr=1e-6)
            history = model.fit(
                x_train, y_train,
                epochs=20,  # Reduced for faster training
                batch_size=32,
                validation_data=(x_test, y_test),
                callbacks=[reduce_lr],
                verbose=0
            )
        
        # Save model
        model.save("lstm_model.keras")
        
        # Store in session state
        st.session_state.model = model
        st.session_state.model_trained = True
        
        st.success("Model trained successfully!")
        return model
        
    except Exception as e:
        st.error(f"Error training model: {e}")
        return None

# --- Utility Functions ---
def preprocess_data(data):
    df = data[['Open', 'High', 'Low', 'Close', 'Volume']].dropna()
    scaler = MinMaxScaler()
    scaled = scaler.fit_transform(df)
    return df, scaled, scaler

def create_dataset(data, y_col_index=3, window_size=120):
    x, y = [], []
    for i in range(window_size, len(data)):
        x.append(data[i - window_size:i])
        y.append(data[i, y_col_index])
    return np.array(x), np.array(y)

def inverse_close(pred, scaler):
    zeros = np.zeros((len(pred), 3))
    zeros_tail = np.zeros((len(pred), 1))
    pred_inversed = scaler.inverse_transform(np.concatenate([zeros, pred, zeros_tail], axis=1))[:, 3]
    return pred_inversed

def forecast_next_days(data, scaler, model, n_days=10):
    last_data = data[-120:]
    forecasts = []
    for _ in range(n_days):
        inp = last_data.reshape((1, last_data.shape[0], last_data.shape[1]))
        pred = model.predict(inp, verbose=0)[0]
        forecasts.append(pred)
        next_input = np.append(last_data[1:], [np.concatenate([last_data[-1][:3], pred, last_data[-1][-1:]])], axis=0)
        last_data = next_input
    return inverse_close(np.array(forecasts), scaler)

# --- Company Selector ---
selected_company = "TCS.NS"
if page == "Select Company":
    st.header("Select Company to Analyze")
    selected_company = st.selectbox("Select Company to Analyze", 
                                   ["TCS.NS", "INFY.NS", "RELIANCE.NS", "HDFCBANK.NS", "ICICIBANK.NS"])
    st.session_state.selected_company = selected_company
    st.success(f"Selected: {selected_company}")

# --- CSV Upload Section ---
data = None
if page == "Data Upload":
    st.header("Upload Stock Data")
    uploaded = st.file_uploader("Upload your CSV file", type="csv")
    if uploaded:
        try:
            data = pd.read_csv(uploaded)
            # Convert Date column to datetime index if it exists
            if 'Date' in data.columns:
                data['Date'] = pd.to_datetime(data['Date'])
                data.set_index('Date', inplace=True)
            st.success("CSV File Uploaded Successfully")
            st.dataframe(data.head())
        except Exception as e:
            st.error(f"Error reading CSV file: {e}")

# --- Fetch Data If Not Uploaded ---
if data is None:
    try:
        today = datetime.datetime.today().strftime('%Y-%m-%d')
        selected_company = st.session_state.get("selected_company", "TCS.NS")
        with st.spinner(f"Fetching data for {selected_company}..."):
            data = yf.download(selected_company, start="2010-01-01", end=today, progress=False)
        
        if data.empty:
            st.error(f"No data found for {selected_company}")
            st.stop()
            
    except Exception as e:
        st.error(f"Error fetching data: {e}")
        st.stop()

# --- Train Model Page ---
if page == "Train Model":
    st.header("Train LSTM Model")
    
    if not TENSORFLOW_AVAILABLE:
        st.error("TensorFlow is required for model training. Please install tensorflow>=2.11.0")
    else:
        col1, col2 = st.columns(2)
        
        with col1:
            st.info("Current model status:")
            if st.session_state.model_trained:
                st.success("✅ Model is trained and ready")
            else:
                st.warning("⚠️ No trained model available")
        
        with col2:
            if st.button("🚀 Train New Model", type="primary"):
                if data is not None and len(data) > 200:
                    train_new_model(data)
                else:
                    st.error("Insufficient data for training. Need at least 200+ data points.")
        
        # Try to load existing model
        if not st.session_state.model_trained:
            load_or_create_model()

# --- Overview Page ---
if page == "Overview":
    st.header("📈 Recent Stock Data Preview")
    st.dataframe(data.sort_index(ascending=False).head(10))

    # Check if model is available
    if not st.session_state.model_trained:
        if not load_or_create_model():
            st.warning("⚠️ No trained model available. Please train a model first.")
            st.stop()

    model = st.session_state.model
    
    try:
        df, scaled_data, scaler = preprocess_data(data)
        x, y = create_dataset(scaled_data)
        
        if len(x) > 0:
            x = x.reshape((x.shape[0], x.shape[1], x.shape[2]))

            with st.spinner("Generating predictions..."):
                y_pred_scaled = model.predict(x, verbose=0)
            y_pred = inverse_close(y_pred_scaled, scaler)
            y_actual = inverse_close(y.reshape(-1, 1), scaler)

            st.header("📉 Historical Forecast vs Actual")
            fig1, ax1 = plt.subplots(figsize=(14, 5))
            
            # Plot last 700 points or all available data
            plot_points = min(700, len(y_actual))
            ax1.plot(y_actual[-plot_points:], label="Actual Price", color='#1f77b4')
            ax1.plot(y_pred[-plot_points:], label="Predicted Price", color='#ff7f0e')
            ax1.set_title("Actual vs Forecasted Closing Price")
            ax1.set_xlabel("Time Frame")
            ax1.set_ylabel("Price (INR)")
            ax1.grid(True)
            ax1.legend()
            st.pyplot(fig1)

            # Calculate metrics
            r2 = r2_score(y_actual, y_pred)
            rmse = np.sqrt(mean_squared_error(y_actual, y_pred))
            mae = mean_absolute_error(y_actual, y_pred)
            
            st.markdown(f"**R² Score:** {r2:.4f}  |  **RMSE:** {rmse:.2f}  |  **MAE:** {mae:.2f}")

            st.header("📋 Recent Forecast Summary")
            recent_points = min(10, len(y_pred))
            pred_df = pd.DataFrame({
                "Date": data.index[-len(y_pred):][-recent_points:].date,
                "Actual": y_actual[-recent_points:],
                "Predicted": y_pred[-recent_points:]
            })
            st.table(pred_df)
        else:
            st.error("Insufficient data for prediction. Need more historical data.")
            
    except Exception as e:
        st.error(f"Error in prediction: {e}")

# --- Forecasting Page ---
if page == "Forecast":
    st.header("🧮 Forecasting Options")
    
    # Check if model is available
    if not st.session_state.model_trained:
        if not load_or_create_model():
            st.warning("⚠️ No trained model available. Please train a model first.")
            st.stop()

    model = st.session_state.model
    
    try:
        df, scaled_data, scaler = preprocess_data(data)
        forecast_mode = st.radio("Choose Forecast Type", ["Next N Days", "Specific Date", "Custom Date Range"])

        if forecast_mode == "Next N Days":
            n = st.number_input("Forecast Horizon (Days)", min_value=1, max_value=100, value=7)
            if st.button("Generate Forecast"):
                with st.spinner("Generating forecast..."):
                    forecasted = forecast_next_days(scaled_data, scaler, model, n)
                dates = pd.date_range(start=data.index[-1]+pd.Timedelta(days=1), periods=n, freq='B')
                result = pd.DataFrame({"Date": dates.date, "Predicted Close": forecasted})
                st.dataframe(result)
                csv = result.to_csv(index=False).encode('utf-8')
                st.download_button("Download Results", csv, "forecast.csv", "text/csv")

        elif forecast_mode == "Specific Date":
            date_input = st.date_input("Select a Future Date")
            st.info("Prediction is based on extrapolation from the last available data point.")
            if st.button("Predict Date"):
                days_gap = (date_input - data.index[-1].date()).days
                if days_gap > 0:
                    with st.spinner("Generating prediction..."):
                        forecasted = forecast_next_days(scaled_data, scaler, model, days_gap)
                    st.success(f"Forecasted Close on {date_input.strftime('%Y-%m-%d')}: ₹{forecasted[-1]:.2f}")
                else:
                    st.error("Date must be later than the last date in the dataset.")

        elif forecast_mode == "Custom Date Range":
            start_date = st.date_input("From Date")
            end_date = st.date_input("To Date")
            if start_date and end_date and end_date > start_date:
                if st.button("Predict Range"):
                    days_gap = (start_date - data.index[-1].date()).days
                    range_days = (end_date - start_date).days + 1
                    if days_gap >= 0:
                        with st.spinner("Generating range forecast..."):
                            forecasted = forecast_next_days(scaled_data, scaler, model, days_gap + range_days)
                        forecasted = forecasted[days_gap:]
                        dates = pd.date_range(start=start_date, periods=len(forecasted), freq='B')
                        result = pd.DataFrame({"Date": dates.date, "Predicted Close": forecasted})
                        st.dataframe(result)
                        csv = result.to_csv(index=False).encode('utf-8')
                        st.download_button("Export CSV", csv, "forecast.csv", "text/csv")
                    else:
                        st.error("The selected start date must be beyond the dataset's range.")
            else:
                st.warning("Please ensure valid start and end dates are selected.")
                
    except Exception as e:
        st.error(f"Error in forecasting: {e}")
        st.error("Please check if the model is properly trained and data is available.")
